---
title: "neural_point_model"
author: "Josh Marvald"
date: "6/11/2020"
output: html_document
---

```{r}
#install.packages("neuralnet")
library(neuralnet)
library(tidyverse)
source("data_cleaning.R")
source("merging_matches.R")
```


```{r}
# keep players with enough matches

# atp
players_keep_atp <- 
  final_atp_df1 %>% 
  group_by(match_id) %>%
  slice(1) %>%
  ungroup() %>%
  pivot_longer(c(player1, player2), names_to = "player", values_to = "name") %>%
  group_by(name) %>%
  summarise(nmatches = n()) %>%
  filter(nmatches >= 30 & is.na(name) == FALSE)

# df for numerical response nn
atp_mod_df <- 
  final_atp_df1 %>% 
  filter(player1 %in% players_keep_atp$name & player2 %in% players_keep_atp$name) %>% 
  mutate(servingplayer = case_when(PointServer == 1 ~ player1, PointServer == 2 ~ player2)) %>%
  mutate(returningplayer = case_when(PointServer == 1 ~ player2, PointServer == 2 ~ player1)) %>%
  filter(is.na(importance2) == FALSE) %>%
  mutate(Nishikori = ifelse(servingplayer == "Kei Nishikori", 1, 0),
         Murray = ifelse(servingplayer == "Andy Murray", 1, 0),
         Thiem = ifelse(servingplayer == "Dominic Thiem", 1, 0),
         Fed = ifelse(servingplayer == "Roger Federer", 1, 0),
         Stan = ifelse(servingplayer == "Stan Wawrinka", 1, 0),
         Nadal = ifelse(servingplayer == "Rafael Nadal", 1, 0),
         Novak = ifelse(servingplayer == "Novak Djokovic", 1, 0),
         Milos = ifelse(servingplayer == "Milos Raonic", 1, 0))

# df for categorical response nn
nn_mod_df <- 
  new_atp_df2 %>% 
  ungroup() %>%
  filter(player1 %in% players_keep_atp$name & player2 %in% players_keep_atp$name) %>% 
  mutate(servingplayer = case_when(PointServer == 1 ~ player1, PointServer == 2 ~ player2)) %>%
  mutate(returningplayer = case_when(PointServer == 1 ~ player2, PointServer == 2 ~ player1)) %>%
  filter(is.na(importance2) == FALSE) %>%
  mutate(ServeSide = ifelse((serve_point + return_point) %% 2 == 0, "Deuce", "Ad"))

# get df with name and handedness
tmp <- 
  gs_decade %>%
  filter(winner_name %in% players_keep_atp$name & loser_name %in% players_keep_atp$name) %>%
  select(winner_name, winner_hand, loser_name, loser_hand) %>%
  gather(key = win_loss, value = name, winner_name, loser_name) %>%
  mutate(hand = case_when(
    win_loss == "winner_name" ~ winner_hand,
    win_loss == "loser_name" ~ loser_hand
  )) %>%
  within(., rm(win_loss, winner_hand, loser_hand))
tmp <- 
  tmp[!duplicated(tmp$name),]

# assign hand variable to servingplayer 
nn_mod_df <-
  left_join(nn_mod_df, tmp, by = c("servingplayer" = "name"))


# 0, 1 for categorical
nn_mod_df <-
  nn_mod_df %>%
  mutate(serve_side = case_when(
    ServeSide == "Deuce" ~ 1,
    ServeSide == "Ad" ~ 0), 
    serve_number = case_when(
      ServeIndicator == 1 ~ 0,
      ServeIndicator == 2 ~ 1),
    serve_depth = case_when(
      ServeDepth == "CTL" ~ 1,
      ServeDepth == "NCTL" ~ 0),
    Handedness = case_when(
      hand == "R" ~ 0,
      hand == "L" ~ 1),
    server_up = case_when(
      (serve_point - return_point) > 0 ~ 1,
      (serve_point - return_point) <= 0 ~ 0
    )) %>%
  filter(is.na(ServeWidth) == F & is.na(serve_number) == F & is.na(serve_depth) == F & is.na(serve_side) == F & is.na(Handedness) == F & is.na(server_up) == F)
```


```{r}
# wta
players_keep_wta <- 
  final_wta_df1 %>% 
  group_by(match_id) %>%
  slice(1) %>%
  ungroup() %>%
  pivot_longer(c(player1, player2), names_to = "player", values_to = "name") %>%
  group_by(name) %>%
  summarise(nmatches = n()) %>%
  filter(nmatches >= 13 & is.na(name) == FALSE)

wta_mod_df <- 
  final_wta_df1 %>% 
  filter(player1 %in% players_keep_wta$name & player2 %in% players_keep_wta$name) %>% 
  mutate(servingplayer = case_when(PointServer == 1 ~ player1, PointServer == 2 ~ player2)) %>%
  mutate(returningplayer = case_when(PointServer == 1 ~ player2, PointServer == 2 ~ player1)) %>%
  filter(is.na(importance2) == FALSE)

nn_wta_df <- 
  new_wta_df2 %>% 
  ungroup() %>%
  filter(player1 %in% players_keep_wta$name & player2 %in% players_keep_wta$name) %>% 
  mutate(servingplayer = case_when(PointServer == 1 ~ player1, PointServer == 2 ~ player2)) %>%
  mutate(returningplayer = case_when(PointServer == 1 ~ player2, PointServer == 2 ~ player1)) %>%
  filter(is.na(importance2) == FALSE) %>%
  mutate(ServeSide = ifelse((serve_point + return_point) %% 2 == 0, "Deuce", "Ad"))

# get df with name and handedness
tmp2 <- 
  wta_gs_decade %>%
  filter(winner_name %in% players_keep_wta$name & loser_name %in% players_keep_wta$name) %>%
  select(winner_name, winner_hand, loser_name, loser_hand) %>%
  gather(key = win_loss, value = name, winner_name, loser_name) %>%
  mutate(hand = case_when(
    win_loss == "winner_name" ~ winner_hand,
    win_loss == "loser_name" ~ loser_hand
  )) %>%
  within(., rm(win_loss, winner_hand, loser_hand))
tmp2 <- 
  tmp2[!duplicated(tmp2$name),]

# assign hand variable to servingplayer 
nn_wta_df <-
  left_join(nn_wta_df, tmp2, by = c("servingplayer" = "name"))

# add variables for 0, 1 for categorical variables
nn_wta_df <-
  nn_wta_df %>%
  mutate(serve_side = case_when(
    ServeSide == "Deuce" ~ 1,
    ServeSide == "Ad" ~ 0), 
    serve_number = case_when(
      ServeIndicator == 1 ~ 0,
      ServeIndicator == 2 ~ 1),
    serve_depth = case_when(
      ServeDepth == "CTL" ~ 1,
      ServeDepth == "NCTL" ~ 0),
    Handedness = case_when(
      hand == "R" ~ 0,
      hand == "L" ~ 1),
    server_up = case_when(
      (serve_point - return_point) > 0 ~ 1,
      (serve_point - return_point) <= 0 ~ 0
    )) %>%
  filter(is.na(ServeWidth) == F & is.na(serve_number) == F & is.na(serve_depth) == F & is.na(serve_side) == F & is.na(Handedness) == F & is.na(server_up) == F)
```


```{r}
# split data
#set.seed(7) 

# make variable for row number
#atp_mod_df$rowID <- 1:nrow(atp_mod_df)
#wta_mod_df$rowID <- 1:nrow(wta_mod_df)

#as.data.frame(atp_mod_df$importance2)

# sample for training data
#atp_train_df <- 
#  atp_mod_df[sample(1:nrow(atp_mod_df), 2000, replace = FALSE), ]

# take the rows in whole data set not in training data set
#atp_test_df <-
#  anti_join(atp_mod_df, atp_train_df, by = "rowID")

# sample for training data
#wta_train_df <-
#  wta_mod_df[sample(1:nrow(wta_mod_df), 3500, replace = FALSE),]

# take the rows in whole data set not in training data set
#wta_test_df <-
#  anti_join(wta_mod_df, wta_train_df, by = "rowID")
```


```{r}
 

# resids <- pr.lm - test$Speed_MPH
# qplot(resids) ## all negative: wrong variable being used in the MSE formula


# resids <- pr.lm - test$RallyCount
# MSE.lm <- sum((resids)^2)/nrow(test)

# max1 <- apply(vars, 2, max)
# min1 <- apply(vars, 2, min)

# new_scaled <- as.data.frame(scale(vars, center = min1, scale = max1 - min1))
# train_ <- new_scaled[index,]
# test_ <- new_scaled[-index,]


# nn <- neuralnet(f, data = train_, hidden = c(2), linear.output = T)
# plot(nn)
```


```{r}
## find predictions 
# pr.nn <- neuralnet::compute(nn, test_)

## these are neural net predictions
# pr.nn2 <- pr.nn$net.result * (max(vars$RallyCount) - min(vars$RallyCount)) + min(vars$RallyCount)


# test.r <- (test$RallyCount) * (max(vars$RallyCount) - min(vars$RallyCount)) + min(vars$RallyCount)
## actual Speed
## this isn't quite right either: you need to backtransform the neural net
## predictions, but, once those are backtransformed, they can
## be directly compared with rally count. 
## 
## a plot can help:

# resids.nn <- test.r - pr.nn2
# qplot(resids.nn) ## shouldn't be overpredicting rally count by 200+ shots

# resids.nn <- test$RallyCount - pr.nn2
## MSE for neural network
# MSE.nn <- sum((resids.nn) ^ 2)/ nrow(test)
# MSE.nn

# print(c(MSE.lm, MSE.nn))
```


```{r}
# split data
set.seed(7) 

# make variable for row number
nn_mod_df$rowID <- 1:nrow(nn_mod_df)
nn_wta_df$rowID <- 1:nrow(nn_wta_df)

as.factor(nn_mod_df$ServeIndicator)
as.data.frame(nn_mod_df$importance2)


# sample for training data
nn_train_df <- 
  nn_mod_df[sample(1:nrow(nn_mod_df), 3000, replace = FALSE), ]

# take the rows in whole data set not in training data set
nn_test_df <-
  anti_join(nn_mod_df, nn_train_df, by = "rowID" )

# sample for training data
nn_wta_train_df <-
  nn_wta_df[sample(1:nrow(nn_wta_df), 7000, replace = FALSE),] 

# take the rows in whole data set not in training data set
nn_wta_test_df <-
  anti_join(nn_wta_df, nn_wta_train_df, by = "rowID")
```


```{r}
# fit model
serve_nn <- neuralnet(ServeWidth ~ serve_number + server_up + serve_depth + serve_side + Handedness,
                      data = nn_train_df,
                      linear.output = FALSE,
                      hidden = c(2,1))
plot(serve_nn)
```


```{r}
# predictions
width_pr <- neuralnet::compute(serve_nn, nn_test_df)


```



