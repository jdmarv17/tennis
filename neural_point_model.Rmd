---
title: "neural_point_model"
author: "Josh Marvald"
date: "6/11/2020"
output: html_document
---

```{r}
#install.packages("neuralnet")
library(neuralnet)
library(tidyverse)
source("data_cleaning.R")
source("merging_matches.R")
```


```{r}
# keep players with enough matches

# atp
players_keep_atp <- 
  final_atp_df1 %>% 
  group_by(match_id) %>%
  slice(1) %>%
  ungroup() %>%
  pivot_longer(c(player1, player2), names_to = "player", values_to = "name") %>%
  group_by(name) %>%
  summarise(nmatches = n()) %>%
  filter(nmatches >= 30 & is.na(name) == FALSE)

# df for numerical response nn
atp_mod_df <- 
  final_atp_df1 %>% 
  filter(player1 %in% players_keep_atp$name & player2 %in% players_keep_atp$name) %>% 
  mutate(servingplayer = case_when(PointServer == 1 ~ player1, PointServer == 2 ~ player2)) %>%
  mutate(returningplayer = case_when(PointServer == 1 ~ player2, PointServer == 2 ~ player1)) %>%
  filter(is.na(importance2) == FALSE) %>%
  mutate(Nishikori = ifelse(servingplayer == "Kei Nishikori", 1, 0),
         Murray = ifelse(servingplayer == "Andy Murray", 1, 0),
         Thiem = ifelse(servingplayer == "Dominic Thiem", 1, 0),
         Fed = ifelse(servingplayer == "Roger Federer", 1, 0),
         Stan = ifelse(servingplayer == "Stan Wawrinka", 1, 0),
         Nadal = ifelse(servingplayer == "Rafael Nadal", 1, 0),
         Novak = ifelse(servingplayer == "Novak Djokovic", 1, 0),
         Milos = ifelse(servingplayer == "Milos Raonic", 1, 0))

# df for categorical response nn
nn_mod_df <- 
  new_atp_df2 %>% 
  ungroup() %>%
  filter(player1 %in% players_keep_atp$name & player2 %in% players_keep_atp$name) %>% 
  mutate(servingplayer = case_when(PointServer == 1 ~ player1, PointServer == 2 ~ player2)) %>%
  mutate(returningplayer = case_when(PointServer == 1 ~ player2, PointServer == 2 ~ player1)) %>%
  filter(is.na(importance2) == FALSE) %>%
  mutate(ServeSide = ifelse((serve_point + return_point) %% 2 == 0, "Deuce", "Ad"))

# get df with name and handedness
tmp <- 
  gs_decade %>%
  filter(winner_name %in% players_keep_atp$name & loser_name %in% players_keep_atp$name) %>%
  select(winner_name, winner_hand, loser_name, loser_hand) %>%
  gather(key = win_loss, value = name, winner_name, loser_name) %>%
  mutate(hand = case_when(
    win_loss == "winner_name" ~ winner_hand,
    win_loss == "loser_name" ~ loser_hand
  )) %>%
  within(., rm(win_loss, winner_hand, loser_hand))
tmp <- 
  tmp[!duplicated(tmp$name),]

# assign hand variable to servingplayer 
nn_mod_df <-
  left_join(nn_mod_df, tmp, by = c("servingplayer" = "name"))

```


```{r}
# wta
players_keep_wta <- 
  final_wta_df1 %>% 
  group_by(match_id) %>%
  slice(1) %>%
  ungroup() %>%
  pivot_longer(c(player1, player2), names_to = "player", values_to = "name") %>%
  group_by(name) %>%
  summarise(nmatches = n()) %>%
  filter(nmatches >= 13 & is.na(name) == FALSE)

wta_mod_df <- 
  final_wta_df1 %>% 
  filter(player1 %in% players_keep_wta$name & player2 %in% players_keep_wta$name) %>% 
  mutate(servingplayer = case_when(PointServer == 1 ~ player1, PointServer == 2 ~ player2)) %>%
  mutate(returningplayer = case_when(PointServer == 1 ~ player2, PointServer == 2 ~ player1)) %>%
  filter(is.na(importance2) == FALSE)

nn_wta_df <- 
  new_wta_df2 %>% 
  ungroup() %>%
  filter(player1 %in% players_keep_wta$name & player2 %in% players_keep_wta$name) %>% 
  mutate(servingplayer = case_when(PointServer == 1 ~ player1, PointServer == 2 ~ player2)) %>%
  mutate(returningplayer = case_when(PointServer == 1 ~ player2, PointServer == 2 ~ player1)) %>%
  filter(is.na(importance2) == FALSE) %>%
  mutate(ServeSide = ifelse((serve_point + return_point) %% 2 == 0, "Deuce", "Ad"))

# get df with name and handedness
tmp2 <- 
  wta_gs_decade %>%
  filter(winner_name %in% players_keep_wta$name & loser_name %in% players_keep_wta$name) %>%
  select(winner_name, winner_hand, loser_name, loser_hand) %>%
  gather(key = win_loss, value = name, winner_name, loser_name) %>%
  mutate(hand = case_when(
    win_loss == "winner_name" ~ winner_hand,
    win_loss == "loser_name" ~ loser_hand
  )) %>%
  within(., rm(win_loss, winner_hand, loser_hand))
tmp2 <- 
  tmp2[!duplicated(tmp2$name),]

# assign hand variable to servingplayer 
nn_wta_df <-
  left_join(nn_wta_df, tmp2, by = c("servingplayer" = "name"))
```


```{r}
# split data
set.seed(7) 

# make variable for row number
atp_mod_df$rowID <- 1:nrow(atp_mod_df)
wta_mod_df$rowID <- 1:nrow(wta_mod_df)

as.data.frame(atp_mod_df$importance2)

# sample for training data
atp_train_df <- 
  atp_mod_df[sample(1:nrow(atp_mod_df), 2000, replace = FALSE), ]

# take the rows in whole data set not in training data set
atp_test_df <-
  anti_join(atp_mod_df, atp_train_df, by = "rowID")

# sample for training data
wta_train_df <-
  wta_mod_df[sample(1:nrow(wta_mod_df), 3500, replace = FALSE),]

# take the rows in whole data set not in training data set
wta_test_df <-
  anti_join(wta_mod_df, wta_train_df, by = "rowID")
```


```{r}

vars <-
  atp_mod_df %>%
  ungroup() %>%
  select(RallyCount, Speed_MPH, importance2, unforcedind, P1DistanceRun, P2DistanceRun) %>%
  filter(is.na(RallyCount) == FALSE)


index <- sample(1:nrow(vars), round(0.75*nrow(vars)))
train <- vars[index,]
test <- vars[-index,]

f <- RallyCount ~ importance2 + P1DistanceRun + P2DistanceRun + Speed_MPH + unforcedind

reg_mod <- lm(f, data = train)
pr.lm <- predict(reg_mod, test)

## this isn't quite right: probably best to look at test "residuals" before
## computing MSE. 

resids <- pr.lm - test$Speed_MPH
qplot(resids) ## all negative: wrong variable being used in the MSE formula


resids <- pr.lm - test$RallyCount
MSE.lm <- sum((resids)^2)/nrow(test)

max1 <- apply(vars, 2, max)
min1 <- apply(vars, 2, min)

new_scaled <- as.data.frame(scale(vars, center = min1, scale = max1 - min1))
train_ <- new_scaled[index,]
test_ <- new_scaled[-index,]


nn <- neuralnet(f, data = train_, hidden = c(2), linear.output = T)
plot(nn)
```


```{r}
## find predictions 
pr.nn <- neuralnet::compute(nn, test_)

## these are neural net predictions
pr.nn2 <- pr.nn$net.result * (max(vars$RallyCount) - min(vars$RallyCount)) + min(vars$RallyCount)


test.r <- (test$RallyCount) * (max(vars$RallyCount) - min(vars$RallyCount)) + min(vars$RallyCount)
## actual Speed
## this isn't quite right either: you need to backtransform the neural net
## predictions, but, once those are backtransformed, they can
## be directly compared with rally count. 
## 
## a plot can help:

resids.nn <- test.r - pr.nn2
qplot(resids.nn) ## shouldn't be overpredicting rally count by 200+ shots

resids.nn <- test$RallyCount - pr.nn2
## MSE for neural network
MSE.nn <- sum((resids.nn) ^ 2)/ nrow(test)
MSE.nn

print(c(MSE.lm, MSE.nn))
```


```{r}
# split data
set.seed(7) 

# make variable for row number
nn_mod_df$rowID <- 1:nrow(nn_mod_df)

as.factor(nn_mod_df$ServeIndicator)
as.data.frame(nn_mod_df$importance2)



# sample for training data
nn_train_df <- 
  nn_mod_df[sample(1:nrow(nn_mod_df), 4000, replace = FALSE), ]

# take the rows in whole data set not in training data set
nn_test_df <-
  anti_join(nn_mod_df, nn_train_df, by = "rowID")

# sample for training data
wta_train_df <-
  wta_mod_df[sample(1:nrow(wta_mod_df), 3500, replace = FALSE),]

# take the rows in whole data set not in training data set
wta_test_df <-
  anti_join(wta_mod_df, wta_train_df, by = "rowID")
```

```{r}
serve_nn <- neuralnet(ServeWidth ~ ServeIndicator + point_score + ServeDepth + ServeSide + hand,
                      data = nn_train_df,
                      linear.output = FALSE,
                      hidden = c(2,1))
```

