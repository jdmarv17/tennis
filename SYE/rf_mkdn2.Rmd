---
title: "rf_markdown"
author: "Josh Marvald"
date: "11/3/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo = FALSE}
library(here)
library(party)
library(tidyverse)
library(forcats)
library(randomForest)
source(here("SYE", "merging_variables.R"))
```


```{r}
# more variables for rf

# get indicator variables for each player winning the point
rf_df <-
  rf_df %>%
  mutate(p1_point = case_when(
    PointWinner == 1 ~ 1,
    PointWinner == 2 ~ 0
  )) %>%
  mutate(p2_point = case_when(
    PointWinner == 1 ~ 0,
    PointWinner == 2 ~ 1
  ))

rf_df$p1Game <- as.numeric(rf_df$p1Game)
rf_df$p2Game <- as.numeric(rf_df$p2Game)
rf_df$PointNumber <- as.numeric(rf_df$PointNumber)

# more variables (total points at each point, surface, rank, games)
rf_df <-
  rf_df %>%
  group_by(slam, year, p1, p2) %>%
  mutate(p1_total_points = 
           cumsum(p1_point)) %>%
  mutate(p2_total_points = 
           cumsum(p2_point)) %>%
  ungroup() %>%
  mutate(point_dif = p1_total_points - p2_total_points) %>%
  mutate(point_total = p1_total_points + p2_total_points) %>%
  mutate(surface = case_when(
    slam == "ausopen" ~ "hard",
    slam == "usopen" ~ "hard",
    slam == "frenchopen" ~ "clay",
    slam == "wimbledon" ~ "grass"
  )) %>%
  mutate(log_rank = log(p1_rankpoints/p2_rankpoints)) %>%
  mutate(surface_numerical = case_when(
    surface == "grass" ~ 0,
    surface == "hard" ~ 1,
    surface == "clay" ~ 2
  )) %>%
  mutate(num_games = p1Game + p2Game) %>%
  mutate(num_sets = (as.numeric(p1Set) + as.numeric(p2Set)))


# get person who serves first in set, break advantage positive if favors p1, negative if favors p2
rf_df <-
  rf_df %>%
  group_by(p1, p2, slam, year, num_sets) %>%
  mutate(serve_first = case_when(
    PointNumber == min(PointNumber) & PointServer == 1 ~ "p1",
    PointNumber == min(PointNumber) & PointServer == 2 ~ "p2"
  )) %>%
  fill(serve_first, .direction = "down") %>%
  ungroup() %>%
  mutate(break_advantage = case_when(
    serve_first == "p1" & game_advantage == 0 | game_advantage == 1 ~ 0, # on serve
    serve_first == "p1" & game_advantage == 2 | game_advantage == 3 ~ 1, # p1 holds, breaks, (holds)
    serve_first == "p1" & game_advantage == 4 | game_advantage == 5 ~ 2, # p1 holds, breaks, holds, breaks, (holds)
    serve_first == "p1" & game_advantage == -1 | game_advantage == -2 ~ -1, # p1 broken, (p2 holds)
    serve_first == "p1" & game_advantage == -3 | game_advantage == -4 ~ -2, # p1 broken, p2 holds, p1 broken, (p2 holds)
    serve_first == "p1" & game_advantage == -5 | game_advantage == -6 ~ -3, # p1 broken, p2 holds, p1 broken, p2 holds, p1 broken, (p2 holds)
    # should game_advantage == -6 be included?
    serve_first == "p2" & game_advantage == 0 | game_advantage == -1 ~ 0, # on serve
    serve_first == "p2" & game_advantage == -2 | game_advantage == -3 ~ -1, # p2 holds, breaks, (holds)
    serve_first == "p2" & game_advantage == -4 | game_advantage == -5 ~ -2, # p2 holds, breaks, holds, breaks, (holds)
    serve_first == "p2" & game_advantage == 1 | game_advantage == 2 ~ 1, # p2 broken, (p1 holds)
    serve_first == "p2" & game_advantage == 3 | game_advantage == 4 ~ 2, # p2 broken, p1 holds, p2 broken, (p1 holds)
    serve_first == "p2" & game_advantage == 5 | game_advantage == 6 ~ 3, # p2 broken, p1 holds, p2 broken, p1 holds, p2 broken, (p1 holds)
    # should game_advantage == 6 be included?
  ))

rf_df2 <-
  rf_df %>%
  unite("all_score", c(p1Set, p2Set, p1Game, p2Game, P1Score, P2Score), sep = "-") 

rf_df2 <-
  rf_df2 %>%
  ungroup() %>%
  mutate(scoreID = group_indices(., all_score))
```

```{r}
temp <-
  rf_df %>%
  filter(match_num == 1101) %>%
  select(serve_first, ServeIndicator, p1Set, p2Set, p1Game, p2Game, p1, p2)

```

```{r}
# check to see if variables were created correctly
check <-
  rf_df %>%
  filter(slam == "wimbledon" & year == "2017" & p1 == "Joao Sousa" & p2 == "Dustin Brown") %>%
  select(p1, p2, p1Set, p2Set, p1Game, p2Game, game_advantage, P1Score, P2Score, serve_first, break_advantage, PointNumber )
```


```{r}
### preparing test and train
  
# get rid of NAs
rf_df <-
  rf_df %>%
  filter(is.na(set_advantage) == F & is.na(game_advantage) == F & is.na(P1Score) == F & is.na(P2Score) == F & is.na(rank_dif) == F & is.na(result) == F & is.na(point_dif) == F & is.na(surface) == F & is.na(surface_numerical) == F & is.na(log_rank) == F 
& is.na(importance2) == F & is.na(serve_first) == F & is.na(break_advantage) == F & is.na(point_total) == F)



# make score a factor so there arent problems with 40-Ad or Ad-40
rf_df$P1Score <- as.factor(rf_df$P1Score)
rf_df$P2Score <- as.factor(rf_df$P2Score)

# get list of matches
match_list <-
  rf_df %>%
  select(year, slam, p1, p2) %>%
  distinct()

set.seed(7)

# sample matches
sample_size <- floor(.7 * nrow(match_list))
index <- sample(seq_len(nrow(match_list)), size = sample_size)

train_matches <- match_list[index, ]
test_matches <- match_list[-index, ]

# join with rf_df to get train and test points
train <- inner_join(rf_df, train_matches)
test <- inner_join(rf_df, test_matches)
```


```{r}
### preparing test and train

# get rid of NAs
rf_df2 <-
  rf_df2 %>%
  filter(is.na(scoreID) == F & is.na(result) == F & is.na(all_score) == F)


# get list of matches
match_list <-
  rf_df2 %>%
  select(year, slam, p1, p2) %>%
  distinct()

set.seed(11)

# sample matches
sample_size <- floor(.7 * nrow(match_list))
index <- sample(seq_len(nrow(match_list)), size = sample_size)

train_matches <- match_list[index, ]
test_matches <- match_list[-index, ]

# join with rf_df to get train and test points
train2 <- inner_join(rf_df2, train_matches)
test2 <- inner_join(rf_df2, test_matches)
```


```{r}
# fit random forest


rf1 <- randomForest(result ~ set_advantage + num_sets + game_advantage + num_games + break_advantage + point_dif + point_total, data = train, ntree = 50, mtry = 5, importance = T)


# using set_advantage + game_advantage + log_rank + point_dif + surface_numerical
# mtry = 3 does better than mtry = 4

# with set_advantage + game_advantage + point_dif + surface_numerical, mtry = 3 (3 better than 4 as well)
# rank_dif does better than log_rank


# rf with all score
rf_allscore <- randomForest(result ~ all_score, data = train2, ntree = 150, mtry = 1, importance = T)
```


```{r}
### HPC Models


#load("rf_allscoreSurface_small.RData")
print(rf_allscore)

# this rf came from 2000 tree done on hpc
load("rf2.RData")
print(rf2)

#load("rf_allscore_real.RData")
#print(rf_allscore_real)

load("rf3.RData")
load("rf4.RData")
```


```{r}
# make sure only points in train are in test
#test2 <-
#  semi_join(x = test2, y = train2, by = "all_score")

# get predictions
preds <- predict(rf4, test)
test <- 
  test %>%
  ungroup %>%
  mutate(predictions = preds) 

```


```{r}
# add categorical variable for probability ranges
test <-
  test %>%
  mutate(ranges = case_when(
    predictions < .1 ~ "ones",
    predictions >= 0.1 & predictions < 0.2 ~ "tens",
    predictions >= 0.2 & predictions < 0.3 ~ "twenties",
    predictions >= 0.3 & predictions < 0.4 ~ "thirties", 
    predictions >= 0.4 & predictions < 0.5 ~ "fourties",
    predictions >= 0.5 & predictions < 0.6 ~ "fifties",
    predictions >= 0.6 & predictions < 0.7 ~ "sixties",
    predictions >= 0.7 & predictions < 0.8 ~ "seventies",
    predictions >= 0.8 & predictions < 0.9 ~ "eighties",
    predictions >= 0.9 ~ "nineties"
  )) %>%
  mutate(ranges2 = case_when(
    predictions >= 0.5 ~ "win",
    predictions < 0.5 ~ "loss"
  ))

test %>%
  group_by(ranges) %>%
  summarise(prop = mean(result))

test %>%
  group_by(ranges2) %>%
  summarise(prop = mean(result))

# make indicator variable to see if prediction was correct
test <- 
  test %>%
  mutate(correct = case_when(
    predictions >= 0.5 & result == 1 ~ 1,
    predictions >= 0.5 & result == 0 ~ 0,
    predictions < 0.5 & result == 1 ~ 0,
    predictions < 0.5 & result == 0 ~ 1
  )) 

test %>%
  summarise(prop = mean(correct))

test %>%
  group_by(num_sets) %>%
  summarise(prop = mean(correct))
```


```{r}
test$num_sets <- as.factor(test$num_sets)
test$PointNumber <- as.numeric(test$PointNumber)

# fed
fed <- 
  test %>%
  filter(p1 == "Roger Federer" & p2 == "Juan Martin del Potro") %>%
  select(p1, p2, p1Set, p2Set, p1Game, p2Game, P1Score, 
         P2Score, PointNumber, PointServer, set_advantage,
         game_advantage, point_dif, num_sets, num_games, point_total, predictions)
  

nadal <-
  test %>%
  filter(p1 == "Rafael Nadal" | p2 == "Rafael Nadal")


fed %>% 
  ggplot(., aes(y = predictions, x = PointNumber, color = num_sets)) +
  geom_line() +
  coord_cartesian(ylim = c(0, 1)) 
```

```{r}
# matches that get to 1-1
tied_matches <-
  rf_df %>%
  filter(p1Set == 1 & p2Set == 1) %>%
  unite("match", c(p1, p2, slam, year), sep = "-")

tied_matches <- tied_matches[!duplicated(tied_matches$match),]

# first_set (0 p1 wins, 1 p2 wins) -- this is a list of matches with who won first set
sets_tied <-
  rf_df %>%
  group_by(p1, p2, slam, year) %>% 
  filter(num_sets == 0) %>%
  mutate(first_set = case_when(
    PointNumber == max(PointNumber) & p1Game > p2Game ~ 0, # whichever player has more games won the set
    PointNumber == max(PointNumber) & p1Game < p2Game ~ 1 
    )) %>%
  filter(is.na(first_set) == F) %>%
  ungroup() %>%
  unite("match", c(p1, p2, slam, year), sep = "-")
# lost 170 matches or so somehow

# keep matches that reached 1-1 sets
sets_tied <-
  sets_tied %>%
  filter(match %in% tied_matches$match)

# first_setWinner (0 if player who won first 
# set lost match, 1 if player who won first set wins match) 
sets_tied <-
  sets_tied %>%
  mutate(first_setWinner = case_when(
    first_set == 0 & result == 0 ~ 1,
    first_set == 1 & result == 1 ~ 1,
    first_set == 0 & result == 1 ~ 0,
    first_set == 1 & result == 0 ~ 0
  ))

### need to figure out how to get one entry per match
sets_tied %>%
  summarise(prop = mean(first_setWinner))
  
  

```


```{r}
prop_test <-
  rf_df %>% 
  mutate(first_set_winner = case_when(
    num_sets == 1 & set_advantage == 1 ~ 0, 
    num_sets == 1 & set_advantage == -1 ~ 1)) %>%
  group_by(p1, p2, slam, year) %>%
  fill(first_set_winner, .direction = "updown") %>% 
  filter(p1Set == 1 & p2Set == 1) %>%
  ungroup() %>%
  unite("match", c(p1, p2, slam, year), sep = "-")

prop_test <- prop_test[!duplicated(prop_test$match), ]

prop_test <-
  prop_test %>%
  mutate(match_result_and_set1 = case_when(
    first_set_winner == 0 & result == 0 ~ 1,
    first_set_winner == 1 & result == 1 ~ 1,
    first_set_winner == 0 & result == 1 ~ 0,
    first_set_winner == 1 & result == 0 ~ 0
  ))

prop_test %>%
  summarise(prop = mean(match_result_and_set1))
```







